# 类继承和多态
## 1. 继承与静态成员
* 1. 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。
* 2. 静态成员遵循通用的访问控制规则。
## 2. 防止继承的发生
如果我们希望定义的某个类，不希望被其他类继承，或者不想考虑它是否适合作为一个基类，C++11提供了一种防止继承发生的方法：在**类名后面跟一个关键字final**。
```
class A final
{
public:
    A(){}
    ~A(){}
};
class B:public A{

};
```
如上代码，编译将报错：
```
error: cannot derive from 'final' base 'A' in derived type 'B'
```
# 多态
当某个虚函数通过指针或者引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。
## 1. 派生类中的虚函数
派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。同样，派生类中虚函数的返回类型也必须与基类函数匹配。
* 注意：该规则存在一个例外，即当类的虚函数返回类型是类本身的指针或者引用时。
* 注意：如果派生类定义了一个函数与基类中虚函数的名字相同，但是形参列表不同，这仍是合法行为。这时，派生类的函数并没有覆盖掉基类中的版本。（**函数重定义**）

# 抽象基类
**含有纯虚函数的类是抽象基类**。

# 继承的构造函数
类不能继承默认构造函数、拷贝构造函数和移动构造函数。如果派生类没有定义这些函数，则编译器位派生类合成它们。

# C++的多态如何实现

C++的多态，总结而言就是，在基类的函数前加上virtual关键字，在派生类中重写（Override）该函数，运行时将会根据所指对象的实际类型来调用相应的函数。如果对象类型是派生类型，则调用派生类的函数；如果对象类型是基类，则调用基类的函数。

## 多态的底层原理是什么？
虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表。  
虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的是一个指针，即虚表指针，指向虚表。

- 1. 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址 
- 2. 编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表。之后在调用虚函数时，能够找到正确的函数
- 3. 所谓的合适的时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只看到了父类，并为父类对象初始化虚表指针。当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表
- 4. 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己定义的虚函数时，在自己的虚函数中将此虚函数的地址添加在后面。

这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数的重写情况，动态地进行调用，从而实现多态性。

