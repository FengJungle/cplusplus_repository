# 智能指针
## 1. shared_ptr
智能指针时模板，创建智能指针时必须指明指针可以指向的类型。shared_ptr允许多个指针指向同一个对象。

### 1.1. shared_ptr支持的操作
```
    shared_ptr<T> sp;   空智能指针，可以指向类型为T的对象
    p                   将p作为判断条件，如果p指向一个对象，则为true
    *p                  解引用p，获得p指向的对象
    p->mem              等价于(*p).mem
    p.get()             返回p中保存的指针。若智能指针释放了其对象，返回的指针所指向的对象也就消失了
    swap(p,q)           交换p和q中的指针
    p.swap(q)

    make_shared<T>(args) 返回一个shard_ptr，指向一个动态分配的类型为T的对象，使用args初始化此对象
    shared_ptr<T>p(q)    p是shared_ptr q的拷贝，此操作会递增q中的计数器。
    p = q                p和q都是shared_ptr，所保存的指针必须能够相互转换。此操作会递减p的引用计数，递增q的引用计数；
                         若p的引用计数变为0，则将其管理的原内存释放
    p.unique()           若p.use_count()为1，返回true，否则返回false
    p.use_count()        返回与p共享对象的智能指针的数量
```
### 1.2. shared_ptr的初始化
* 1. 默认初始化的shared_ptr保存着一个空指针
```
shared_ptr<int> p;
```
* 2. 使用make_shared<T>
```
shared_ptr<int> p = make_shared<int>(10);
cout<<*p<<endl;  // 输出10
```
* 3. 与new结合，必须使用直接初始化
```
shared_ptr<int> p1 = new int(10); // error：必须使用直接初始化
shared_ptr<int> p2(new int(11));  // success!
```
### 1.3. shared_ptr的引用计数
每个shared_ptr都有一个关联的计数器，称为**引用计数**。无论何时，拷贝一个shared_ptr，计数器会递增。当给一个shared_ptr赋予一个新值或者shared_ptr被销毁，计数器会递减。**当一个shared_ptr引用计数为0时，它就会自动释放自己管理的对象**。
```
shared_ptr<int> pInt = make_shared<int>(10);
cout << "*pInt = " << *pInt << endl;                   // 10
cout << "pInt.unique() = " << pInt.unique() << endl;   // 1
cout << "pInt.count() = " << pInt.use_count() << endl; // 1

{
    shared_ptr<int> q = pInt;
    cout << pInt.use_count() << endl; // 2
    cout << q.use_count() << endl;    // 2
    cout << q.unique() << endl;       // 0
}
// 离开大括号后，引用计数减一

shared_ptr<int> p3(pInt);
cout << p3.use_count() << endl;   // 2
cout << pInt.use_count() << endl; // 2
```
### 1.4. shared_ptr的get方法
shared_ptr的get方法会返回其保存的指针。但要小心使用，**若智能指针释放了其对象，返回的指针所指向的对象也就消失了**。
```
// 使用shared_ptr的get()方法
int* p5= nullptr;
{
    shared_ptr<int> p4 = make_shared<int>(11);
    int *p5 = p4.get();
    cout << "p5 = " << p5 << "\t*p5 = " << *p5 << endl;  // p5 = 0x4da3f0   *p5 = 11
}
// 离开大括号后，智能指针p4所管理的指针已经被智能指针释放了
cout << "p5 = " << p5 << endl;  // p5 = 0，此时再访问p5将报错
```
同样，如果普通指针提前显式释放了智能指针管理的对象，那么智能指针也不能够再使用
```
int *d = nullptr;
{
    shared_ptr<int> p1(new int(3));
    int* d = p1.get();
    delete d;

    // 该行代码报错，因为d已经被释放了W
    cout << p1.use_count() << endl;
}
```
### 1.5. shared_ptr的reset方法
