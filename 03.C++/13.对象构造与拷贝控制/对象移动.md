# 对象移动
C++11新标准的一个主要特性是可以移动而非拷贝对象的能力。很多情况下都会发生拷贝，但其中某些情况下，对象拷贝后就立即销毁了。在这些情况下，移动而非拷贝对象会大大提升性能。

## 1. 左值引用与右值引用

**右值引用**： 
- a. 必须绑定到右值的引用;
- b. 通过 && 来获得右值引用;
- c. 右值引用只能绑定到一个将要销毁的对象；
- d. 右值引用不能绑定到一个左值上；
- e. 可以将一个const的左值引用绑定到右值引用上；
- f. 不能将一个右值引用绑定到 右值引用类型的变量 上；（因为变量是左值）  

**左值引用**：绑定到左值的引用，不能将其绑定到要求转换的表达式、字面常量或返回右值的表达式。

* 注意：变量是左值，**不能将一个右值引用绑定到一个右值引用类型的变量上**。

## 2. move函数

显示地将一个左值转换为对应的右值引用类型
```
int &&r = std::move(r1);
```
move告诉编译器：r1是一个左值，但是我们希望像一个右值一样处理它。
使用move，即承诺：除了对r1赋值或者销毁它以外，我们将不再使用它。
```
void test1()
{
    int i = 10;               // i是一个左值，有存储地址
    int &r1 = i;              // Right, r1是一个左值引用，绑定到左值i
    int &r2 = 11;             // Wrong, 42是一个右值
    int &r3 = i * 12;         // Wrong, i*42是临时表达式的结果，是一个右值
    const int &r4 = i * 13;   // Right, 可以将一个const左值引用绑定到右值
    int &&r5 = i;             // Wrong, i是一个左值，右值引用r4不能绑定到左值
    int &&r6 = 14;            // Right, 13是一个右值
    int &&r7 = i * 15;        // Right, i*14的结果是一个右值
    int &&r8= r7;             // Wrong, r7是一个 右值引用变量 ，是一个左值
    int &&r9 = std::move(r7); // Right, move告诉编译器，将左值r7转换为对应的右值类型
}
```
### 3. 移动构造函数和移动赋值运算符
自己定义的类型也可以支持移动操作，即需要定义移动构造函数和移动赋值运算符。  

移动构造函数的第一个参数是该类类型的一个右值引用。除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属于新创建的对象。

与拷贝构造函数不同的是，**移动构造函数不分配任何新内存**，它接管给定的源对象中的内存

#### 移后源对象必须可析构
从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。因此，当编写一个移动操作后，必须确保移后源对象进入一个可析构的状态。

除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的。对象有效是指，可以安全地为其赋予新值，或者可以安全地使用而不依赖其当前值。