#include <iostream>
#include <utility>
using namespace std;

/*

对象移动：

C++11新标准

1. 左值引用与右值引用

右值引用： a. 必须绑定到右值的引用;
          b. 通过 && 来获得右值引用;
          c. 右值引用只能绑定到一个将要销毁的对象；
          d. 右值引用不能绑定到一个左值上；
          e. 可以将一个const的左值引用绑定到右值引用上；
          f. 不能将一个右值引用绑定到 右值引用类型的变量 上；（因为变量是左值）
左值引用：绑定到左值的引用，不能将其绑定到要求转换的表达式、字面常量或返回右值的表达式。

2. move函数

显示地将一个左值转换为对应的右值引用类型

    int &&r = std::move(r1);

move告诉编译器：r1是一个左值，但是我们希望像一个右值一样处理它。
使用move，即承诺：除了对r1赋值或者销毁它以外，我们将不再使用它。

*/

// 左值引用与右值引用
void test1()
{
    int i = 10;               // i是一个左值，有存储地址
    int &r1 = i;              // Right, r1是一个左值引用，绑定到左值i
    int &r2 = 11;             // Wrong, 42是一个右值
    int &r3 = i * 12;         // Wrong, i*42是临时表达式的结果，是一个右值
    const int &r4 = i * 13;   // Right, 可以将一个const左值引用绑定到右值
    int &&r5 = i;             // Wrong, i是一个左值，右值引用r4不能绑定到左值
    int &&r6 = 14;            // Right, 13是一个右值
    int &&r7 = i * 15;        // Right, i*14的结果是一个右值
    int &&r8= r7;             // Wrong, r7是一个 右值引用变量 ，是一个左值
    int &&r9 = std::move(r7); // Right, move告诉编译器，将左值r7转换为对应的右值类型
}

/*

3. 移动构造函数

a. 移动构造函数的第一个参数是 该类类型的一个右值引用

b. 除了完成资源移动，移动构造函数还必须保证移后源对象处于这样一个状态：销毁它是无害的

c. 移动构造函数不分配新内存，它接管给定的源对象中的内存




*/