# 1. connect函数
TCP客户端调用connect函数来建立与TCP服务器的连接。调用connect函数将激发TCP的三路握手过程，而且仅在连接建立成功或者失败才返回。其中出错返回可能有以下几种情况：
#### 1.1. 如果TCP客户没有收到SYN分节的响应，则返回ETIMEDOUT错误。
举例来说，如果客户发送一个SYN分节，若无响应则等待6s后再发一次，若仍无响应则等待24s后再次发送一个，若总共等待来75s后仍旧未收到响应，则返回ETIMEDOUT错误。
#### 1.2. 如果服务器主机在该指定的端口上没有进程在等待与之连接，则返回RST
这是一种hard error。客户一收到RST就马上返回ECONNREFUSED错误。
RST是TCP在发生错误时发送的一种TCP分节。产生RST分节的3个条件是：
(1). SYN分节到达了某端口，但在该端口上没有正在监听的服务器；
(2). TCP想取消一个已有连接；
(3). TCP接收到一个根本不存在的连接上的分节。
#### 1.3. 如果客户发送的SYN在中间的某个路由器上引发了一个destination unreachable（目的地不可达）的ICMP错误，则认为是一种软错误。客户主机保存该消息，并且按照1.1情况所述的时间间隔继续发送SYN。若在规定时间内（比如75s）仍未收到相应，则返回EHOSTUNREACh或ENETUNREACH错误给进程。

# 2. bind函数
把一个本地协议地址赋予给一个套接字

bind函数常返回的一个错误是：EADDRINUSE（"Address already in use"）

# 3. listen函数
内核维护两个队列，两个队列中元素数量的和 = backlog
(1). 已完成连接队列(ESTABLISHED)：三路握手完成的队列
(2). 未完成连接队列(SYN_RCVD):接收到SYN分节
注意：当一个SYN分节到达时，如果队列是满的，TCP就该忽略此分节，而不是发送RST。因为：
（1）队列满的情况是暂时的，客户TCP将重发SYN。如果服务器TCP立即响应一个RST，客户的connect会立即给进程返回一个错误，强制应用进程处理该错误，而不是让TCP正常的重传机制来处理。
（2）客户无法区分RST是由于该端口没有服务器在监听，还是由于该端口有服务器在监听，只不过它队列满了。

# 4. accept函数
由服务端调用，用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，则进程被置于休眠状态。

# 5. 异常情况下TCP的状态
* 1. 服务器进程终止：服务器TCP会向客户端TCP发送一个FIN
* 2. 服务器主机崩溃：客户TCP将持续重传没有收到ACK的数据分组，直到服务器返回**ETIMEDOUT**错误。然而如果中间某个路由器判定服务器主机已不可达，从而响应一个destination unreachable的ICMP消息。那么所返回的错误是**EHOSTUNREACH**或**ENETUNREACH**。
* 3. 服务器主机崩溃后重启：服务器主机崩溃后重启，假设客户发送一个数据，服务器重启后，它的TCP丢失了崩溃前的所有连接信息，因此服务器TCP返回一个RST。
* 4. 服务器主机关机：系统关机时，init进程会先给所有进程发送SIGTERM信号，等待一段固定的时间，然后给所有仍在运行的进程发送SIGKILL信号。当服务器子进程终止时，它的所有打开的描述符都被关闭，会向客户TCP发送一个FIN。