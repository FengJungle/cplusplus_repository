# 消息队列
消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。
 
Linux用宏**MSGMAX**和**MSGMNB**来限制一条消息的最大长度和一个队列的最大长度。

# 在Linux中使用消息队列

## 1、msgget函数
该函数用来创建和访问一个消息队列。它的原型为：
```
int msgctl(int msgid, int command, struct msgid_ds *buf);
```
　　
command是将要采取的动作，它可以取3个值，
* IPC_STAT：把msgid_ds结构中的数据设置为消息队列的当前关联值，即用消息队列的当前关联值覆盖msgid_ds的值。
* IPC_SET：如果进程有足够的权限，就把消息列队的当前关联值设置为msgid_ds结构中给出的值
* IPC_RMID：删除消息队列
 
buf是指向msgid_ds结构的指针，它指向消息队列模式和访问权限的结构。msgid_ds结构至少包括以下成员：
```
struct msgid_ds
{
    uid_t shm_perm.uid;
    uid_t shm_perm.gid;
    mode_t shm_perm.mode;
};
```　　
成功时返回0，失败时返回-1.


# 消息队列与命名管道的比较
 
消息队列跟命名管道有不少的相同之处，通过与命名管道一样，消息队列进行通信的进程可以是不相关的进程，同时它们都是**通过发送和接收的方式**来传递数据的。在命名管道中，发送数据用write，接收数据用read，则在消息队列中，发送数据用msgsnd，接收数据用msgrcv。而且它们对每个数据都有一个最大长度的限制。
 
与命名管道相比，消息队列的优势在于:
* 1、消息队列也可以独立于发送和接收进程而存在，从而消除了在同步命名管道的打开和关闭时可能产生的困难。
* 2、同时通过发送消息还可以避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法。
* 3、接收程序可以通过消息类型有选择地接收数据，而不是像命名管道中那样，只能默认地接收。