# 进程间通信
每个进程各⾃有不同的⽤户地址空间,任何⼀个进程的全局变量在另⼀个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟⼀块缓冲区,进程1把数据从⽤户空间拷到内核缓冲区,进程2再从内核缓冲区把数据读⾛,内核提供的这种机制称为**进程间通信**(IPC,InterProcess Communication) 

## 进程通信的应用场景

- 数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。
- 共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。
- 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。
- 资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。
- 进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

## 常用的进程间通信方式：

- 传统的进程间通信方式:无名管道(pipe)、有名管道(fifo)和信号(signal)
- System v IPC对象:共享内存(share memory)、消息队列(message queue)和信号量
- C.BSD:套接字(socket) 

## 1. pipe
### 1.1. 管道特点

- 1.管道只允许具有血缘关系的进程间通信，如父子进程间的通信。
- 2.管道只允许**单向通信**。
- 3.管道内部保证同步机制，从而保证访问数据的一致性。
- 4.面向字节流
- 5.管道随进程，进程在管道在，进程消失管道对应的端口也关闭，两个进程都消失管道也消失。

### 1.2. pipe
* 原理：管道实为内核使用**环形队列机制**（以便管道可以重复利用），借助内核缓冲区（4k）实现
* 本质：是一个伪文件（实为内核缓冲区），由两个文件描述符引用，一个表示读端，一个表示写端。数据从管道的写端流入，从读端流出。

* 管道缓冲区大小
```
//命令查看当前系统中创建管道文件所对应的内核缓冲区的大小
ulimit -a
```

### 1.3. 管道的读写行为

#### 1).读管道
1.管道中有数据，read返回实际读到的字节数。  
2.管道中无数据：  
（1）管道写端被全部关闭，read返回0  
（2）管道写端没有全部被关闭，read阻塞等待（等待管道中有数据可读）  
#### 2).写管道
1.管道读端全部被关闭，进程异常终止。  
2.管道读端没有全部关闭：  
（1）管道已满，write阻塞。  
（2）管道未满，write将数据写入，并返回实际写入的字节数。  
## 2. FIFO
有名管道也叫命名管道，在文件系统目录中存在一个管道文件。管道文件仅仅是文件系统中的标示，**并不在磁盘上占据空间**。在使用时，**在内存上开辟空间**，作为两个进程数据交互的通道。
### 2.1. 管道文件的创建：
1) 在shell中使用mkfifo 命令 
```
mkfifo filename
```
2) mkfifo 函数 (在代码中使用其创建管道文件) 
```
#include <sys/types.h>
#include <sys/stat.h>

int mkfifo(const char *filename,mode_t mode);
```
### 2.2. 使用方式：
1）使用open函数打开管道文件  
如果一个进程以只读(只写)打开，那么这个进程会被阻塞到open，直到另一个进程以只写(只读)或者读写。  
2）使用read函数读取内容  
read读取普通文件，read不会阻塞。而read读取管道文件，read会阻塞运行，直到管道中有数据或者所有的写端关闭。  
3）使用write函数发送内容，使用close函数关闭打开的文件。

## 3. 信号量

信号量是一个计数器,可以用来控制多个线程对共享资源的访问.**它不是用于交换大批数据,而用于多线程之间的同步**.它常作为一种**锁机制**,防止某进程在访问资源时其它进程也访问该资源.因此,主要作为进程间以及同一个进程内不同线程之间的同步手段.

Linux提供了一组精心设计的信号量接口来对信号进行操作，它们不只是针对二进制信号量，下面将会对这些函数进行介绍，但请注意，这些函数都是用来对成组的信号量值进行操作的。它们声明在头文件sys/sem.h中。

* semget函数: 它的作用是创建一个新信号量或取得一个已有信号量
* semop函数: 它的作用是改变信号量的值
* semctl函数: 该函数用来直接控制信号量信息

## 4.信号

信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生.
## 5.消息队列

消息队列是消息的链表,存放在内核中并由消息队列标识符标识.消息队列克服了信号传递信息少,管道只能承载无格式字节流以及缓冲区大小受限等特点.消息队列是UNIX下不同进程之间可实现共享资源的一种机制,UNIX允许不同进程将格式化的数据流以消息队列形式发送给任意进程.对消息队列具有操作权限的进程都可以使用msget完成对消息队列的操作控制.通过使用消息类型,进程可以按任何顺序读信息,或为消息安排优先级顺序.

消息队列本质上是**位于内核空间的链表**，链表的每个节点都是一条消息。每一条消息都有自己的**消息类型**，消息类型用整数来表示，而且必须大于 0。每种类型的消息都被对应的链表所维护.

### 5.1. 消息队列相关的函数
```
// 创建和获取 ipc 内核对象
int msgget(key_t key, int flags);

// 将消息发送到消息队列
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);

// 从消息队列获取消息
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);

// 查看、设置、删除 ipc 内核对象（用法和 shmctl 一样）
int msgctl(int msqid, int cmd, struct msqid_ds *buf);

```
## 6.共享内存

共享内存就是映射一段能被其他进程所访问的内存,这段共享内存由一个进程创建,但多个进程都可以访问.共享内存是**最快**的IPC(进程间通信)方式,它是针对其它进程间通信方式运行效率低而专门设计的.它往往与其他通信机制,如信号量,配合使用,来实现进程间的同步与通信.
## 7.套接字

socket，即套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。

套接字的特性由3个属性确定，它们分别是：域、类型和协议。