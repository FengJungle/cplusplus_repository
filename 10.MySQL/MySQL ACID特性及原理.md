# 1. MySql事务
事务是访问和更新数据库的**一个最小的不可再分的工作单元**。通常一个事务对应一个完整的业务。一个完整的业务需要批量的DML(insert、update、delete)语句共同联合完成。

# 2. 事务的特性ACID
- 原子性：指事务是一个不可分割的工作单元，事务中的操作要么都发生，要么都不发生。
- 一致性：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败。
- 隔离性：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
- 持久性：指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。

## 2.1. 原子性
原子性是指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作执行都成功，才算整个事务成功。如果事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。

### 2.1.1. 原子性的实现原理：undo log
原子性的体现是：回滚。如果MySql报错，则会执行回滚，回滚到执行之前的状态。如何回滚到之前的状态？需要将之前的状态记录下来，根据记录回滚到之前的正确状态。当事务对数据库进行修改时，InnoDB会生成对应的undo log，记录SQL执行的相关信息。当语句执行失败发生回滚，InnoDB会根据undo log记录的信息执行相反的操作（insert -> delete, update -> 相反的update）。



## 2.3. 隔离性
### 2.3.1. 隔离性的4个级别
事务隔离性存在的隔离级别，理论上隔离级别包括4个：
* 第一级别：读未提交（read uncommitted），对方事务还未提交，当前事务可以读取到对方未提交的数据。读未提交存在**脏读**(dirty read)现象，表示读到了脏的数据（缓存中的数据，不稳定）。

* 第二级别：读已提交（read committed），对方事务提交之后的数据我方可以读取到。这种隔离界别解决了**脏读现象**。读已提交存在的问题是**不可重复读**。即如果对方多次提交，我方在同一个mysql中读取的数据在变化，重复读取的数据在变化。

* 第三级别：可重复读（repeatable read）,这种隔离级别解决了**不可重复读问题**。这种级别存在的问题是**幻读**，即**读取到的数据是幻象**，对方已经修改了数据，而我方读取到的是之前的数据。

* 第四级别：序列化读/串行化读，解决了所有问题，但是多个事务必须排队，效率低，需要排队。
**注意：**
* Oracle数据库默认的隔离级别是：读已提交；mysql默认的隔离级别是：可重复读。 
* mysql事务默认情况下是自动提交的，只要执行任意一条DML语句，就提交一次。 
如何关闭自动提交：start transaction;

### 2.3.2. 写写操作：锁
写写操作通过锁保证隔离性。InnoDB有行锁、表锁、间隙锁等。锁能保证同一时刻只有一个事务在操作数据。其他事务必须等待当前事务提交或者回滚之后才可以操作。

#### 1. 行锁（行级锁）
- 1. 行锁防止脏读：A update某一行数据，在未commit的情况下，B不会读到这行数据的更新。在未commit的情况下，A一直持有锁，其他事务不可见。
- 2. 两个事务同时操作一行数据：A update某一行数据完成，B去update该行数据会被阻塞；此时产生了行锁的竞争，行锁被A的sql语句持有，所以B的sql语句被阻塞。A执行commit操作之后，A释放了行锁，B的sql语句立即执行完。

#### 2. 表锁
索引失效，由行级锁升级为表锁。一旦发生表锁，并发度会很低。

索引失效的引发条件之一：使用or语句。

##### Example
A执行如下Sql语句（含or语句），索引失效
```
update t_user set b = 'b4' where id = 1 or id = 2;
```
此时，B执行如下sql语句会阻塞：
```
update t_user set b = 'b4' where id = 3;
```
A和B操作的是不同的行的数据，如果是行级锁，B是不会阻塞的。只有升级成表锁的时候，B才会阻塞。只有A commit之后，B才会操作成功。**如果整个表都锁了，操作表里的任何数据，都是阻塞的**。

#### 3. 间隙锁
下数的表id 1、2、3、4、5是连续的，没有间隙。
```
+------+------+
| id   | name |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
|    4 | d    |
|    5 | e    |
+------+------+
```
而下表的id是1、3、5、7、9，中间存在间隙，间隙引发的锁叫做间隙锁。
```
+------+------+
| id   | name |
+------+------+
|    1 | a    |
|    3 | b    |
|    5 | c    |
|    7 | d    |
|    9 | e    |
+------+------+
```
**间隙锁一般发生在范围查询时**，比如当A执行如下语句：
```
update t_user set name = 'ggg' where id > 1 and id < 9;
```
再在B的会话中执行下列插入语句：
```
insert into t_user (id, name) values (4, 'kj');
```
在A没有commit时，B的插入操作会阻塞。因为A的语句1-9整个范围都被锁上了，往间隙里插入数据会被阻塞。间隙锁的性能影响也很大，假设要操作10000行数据，那么这10000行数据都被锁住，极大影响数据库的操作。

### 2.3.3. 写读操作：MVCC
写读操作存在脏读、不可重复读和幻读的问题。

## 2.4. 持久性
指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。

### 2.4.1. 持久性的实现原理：redo log
* 背景：MySql的数据存储在磁盘中，如果每次读取数据都去磁盘io读取，效率会很低。InnoDB提供了一个缓存buffer，buffer中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。当从数据库中读取数据，会首先从buffer中读取。当向数据库中写入数据，会首先写入buffer，然后定期将buffer中的数据刷新到磁盘上。

* 优点：提高数据访问效率

* 存在问题：**增加数据丢失的风险**。如果buffer中的数据还没来得及同步到磁盘上，此时MySql宕机了，那么buffer中的数据会丢失，无法保证持久性。

* 解决方法：引入**redo log**。当数据库中的数据要进行新增和修改时，会首先将此次进行的操作先写入redo log日志，再写入到buffer中，即预写式日志。如果故障发生，可以根据redo log恢复数据。

* 问题：既然redo log也会写入到磁盘，那么为什么它会比直接将buffer中的数据写入到磁盘中要快呢？
- 1. buffer中的数据的持久化是随机写的io，每次数据修改的位置是随机的；redo log是追加模式的，每次都是在日志文件尾部追加，是顺序io的操作。这种方式相较更快。
- 2. buffer持久化数据是以数据页page为单位，mysql默认的数据页的大小是16k。一个数据页上一个小小的修改都需要把整个页的数据写入；redo log只写入真正修改的数据，大大减少了无效的io。

* redo log同步到磁盘的时机
首先，没有提交的事物在出现异常时，可以通过undo log回滚。  
其次，对于redo log，有几种持久化机制：
    * 0. 表示当提交事务时，不将buffer中的redo日志写入到磁盘的日志文件中，而是等待主线程每秒刷新同步一次。
    * 1. 事务提交时会把缓冲区中的redo log同步写入到磁盘中，保证一定会写入成功。
    * 2. 事务提交时，redo log异步写入磁盘。
