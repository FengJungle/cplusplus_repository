# MySql索引
## 1. 什么是索引
索引相当于一本书的目录，通过目录可以快速找到对应的资源。在数据库方面，查询一张表有两种检索方式：  
- 1. 全表扫描
- 2. 根据索引检索（效率很高）

索引为什么可以提高检索效率：最根本的原理是缩小了检索的范围。
* **注意**：索引虽然可以提高检索效率，但不能随意添加索引，因为索引也是数据库中的对象，需要数据库不断的维护，是有维护成本的。比如表中的数据经常被修改，就不适合添加索引，因为数据一旦被修改，索引就需要重新排序，进行维护。

添加索引是给某一字段，或者某些字段添加索引。
```
select ename, sal from emp where ename = 'SMITH';
```
当ename字段上没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值  
当ename字段上添加索引的时候，以上sql语句会根据索引扫描，快速定位  

## 2. 创建索引和删除索引
### 2.1. 创建索引
* 语法：
```
create index
    索引名
on
    表名(要创建索引的字段名);
```
* Example：给emp表的sal字段添加索引：
```
create index emp_sal_index on emp(sal);
```
### 2.2. 删除索引
```
drop index 索引名 on 表名;
```
## 3. 什么时候考虑添加索引
* 数据量庞大（根据客户需求和线上的环境）
* 该字段很少DML操作，因为字段进行修改操作，索引也需要维护
* 该字段经常出现在**where**子句中（经常根据哪个字段查询）

## 4. 注意
主键和具有unique约束的字段会自动添加索引，所以根据主键查询效率较高。尽量根据主键检索。

## 5. 查看sql语句的执行计划
* 首先，不添加索引，查询工资等于5000的员工名字：
```
explain select ename, sal from emp where sal = 5000;

mysql> explain select ename, sal from emp where sal = 5000;
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
1 row in set (0.02 sec)
// 注意：type-all，rows = 14，即扫描了全表
```
* 然后，给sal添加索引，再次查询：
```
mysql> create index emp_sal_index on emp(sal);
Query OK, 0 rows affected (0.24 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select ename, sal from emp where sal = 5000;
+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+
| id | select_type | table | type | possible_keys | key           | key_len | ref   | rows | Extra       |
+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+
|  1 | SIMPLE      | emp   | ref  | emp_sal_index | emp_sal_index | 9       | const |    1 | Using where |
+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+
1 row in set (0.00 sec)

// 注意：row = 1
```

## 6. 索引的底层原理：B+Tree
B+Tree介绍：https://blog.csdn.net/hao65103940/article/details/89032538

## 7. 索引的底层实现原理
- 1. 当创建索引的sql语句执行后，在内存或硬盘中（取决于存储引擎）会生成一个索引对象。原表中每个数据都存储在一个唯一的物理地址。
```
create index index_ename on emp(ename);
```
- 2. 索引会自动排序。排序时数据和其物理地址在一块。  
- 3. 索引会分区，将数据按区拆分开，存储在B+Tree上
- 4. 当查询时，会首先检查所要查询的字段是否有索引，如果有，则找到该字段对应的索引对象，然后通过索引检索
```
select ename from emp where ename = 'SMITH';
```
- 5. 检索时，先根定位到某个区，继续定位第二个区...**缩短了扫描范围和数量**，很快定位到SMITH，并且取到SMITH存储的物理地址。
- 6. 此时上面的查询语句变化为如下：
```
select ename from emp where 物理地址 = SMITH的物理地址;
```
此时，MySql不会再去表中取数据，而是**直接定位到SMITH的物理地址**，效率是最高的。

## 8. 索引的分类
* 单一索引：给单个字段添加索引
* 复合索引：给多个字段联合起来添加索引
* 主键索引：主键上会自动添加索引
* 唯一索引：有unique约束的字段会自动添加索引
* ...

## 9. 索引什么时候会失效
* 模糊查询时第一个字符使用的是%，索引会失效。
